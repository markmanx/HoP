(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["reactElementPan"] = factory(require("react"));
	else
		root["reactElementPan"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(1);
	var eventListener = __webpack_require__(2);

	var PropTypes = React.PropTypes;

	var ElementPan = React.createClass({
	    displayName: 'ElementPan',

	    propTypes: {
	        className: PropTypes.string,
	        onPanStart: PropTypes.func,
	        onPan: PropTypes.func,
	        onPanStop: PropTypes.func,
	        startX: PropTypes.number,
	        startY: PropTypes.number,
	        width: PropTypes.number,
	        height: PropTypes.number,
	        style: PropTypes.object
	    },

	    getDefaultProps: function() {
	        return {
	            className: 'element-pan'
	        };
	    },

	    getInitialState: function() {
	        return {
	            dragging: false
	        };
	    },

	    onDragStart: function(e) {
	        e.preventDefault();

	        // We want to be able to pan around inside the container even when the
	        // mouse is on the outside of the element (as long as the mouse button
	        // is still being pressed) - this is why we're attaching to the window
	        eventListener.add(window, 'mousemove', this.onDragMove);
	        eventListener.add(window, 'touchmove', this.onDragMove);
	        eventListener.add(window, 'mouseup', this.onDragStop);
	        eventListener.add(window, 'touchend', this.onDragStop);

	        // If we have multiple child nodes, use the scroll[Height/Width]
	        // If we have no child-nodes, use bounds to find size of inner content
	        var bounds, target = this.el.firstChild;
	        if (target.childNodes.length > 1) {
	            bounds = { width: target.scrollWidth, height: target.scrollHeight };
	        } else {
	            bounds = e.target.getBoundingClientRect();
	        }

	        // Find start position of drag based on touch/mouse coordinates
	        var startX = typeof e.clientX === 'undefined' ? e.changedTouches[0].clientX : e.clientX,
	            startY = typeof e.clientY === 'undefined' ? e.changedTouches[0].clientY : e.clientY;

	        var state = {
	            dragging: true,

	            elHeight: this.el.clientHeight,
	            elWidth: this.el.clientWidth,

	            startX: startX,
	            startY: startY,

	            scrollX: this.el.scrollLeft,
	            scrollY: this.el.scrollTop,

	            maxX: bounds.width,
	            maxY: bounds.height
	        };

	        this.setState(state);

	        if (this.props.onPanStart) {
	            this.props.onPanStart(state);
	        }
	    },

	    onDragMove: function(e) {
	        if (!this.state.dragging) {
	            return;
	        }

	        var x = typeof e.clientX === 'undefined' ? e.changedTouches[0].clientX : e.clientX,
	            y = typeof e.clientY === 'undefined' ? e.changedTouches[0].clientY : e.clientY;

	        // Letting the browser automatically stop on scrollHeight
	        // gives weird bugs where some extra pixels are showing.
	        // Substracting the height/width of the container from the
	        // inner content seems to do the trick.
					let scrollLeft = Math.min(
	            this.state.maxX - this.state.elWidth,
	            this.state.scrollX - (x - this.state.startX)
	        );

					TweenMax.to(this.el, 0.3, {scrollLeft: scrollLeft})

					/*
					this.el.scrollLeft = Math.min(
	            this.state.maxX - this.state.elWidth,
	            this.state.scrollX - (x - this.state.startX)
	        );
					*/

					let scrollTop = Math.min(
	            this.state.maxY - this.state.elHeight,
	            this.state.scrollY - (y - this.state.startY)
	        );

					TweenMax.to(this.el, 0.3, {scrollTop: scrollTop})

					/*
	        this.el.scrollTop = Math.min(
	            this.state.maxY - this.state.elHeight,
	            this.state.scrollY - (y - this.state.startY)
	        );
					*/

	        if (this.props.onPan) {
	            this.props.onPan({ x: this.el.scrollLeft, y: this.el.scrollTop });
	        }
	    },

	    onDragStop: function() {
	        this.setState({ dragging: false });

	        eventListener.remove(window, 'mousemove', this.onDragMove);
	        eventListener.remove(window, 'touchmove', this.onDragMove);
	        eventListener.remove(window, 'mouseup', this.onDragStop);
	        eventListener.remove(window, 'touchend', this.onDragStop);

	        if (this.props.onPanStop) {
	            this.props.onPanStop({ x: this.el.scrollLeft, y: this.el.scrollTop });
	        }
	    },

	    componentDidMount: function() {
	        // Cached for faster lookup
	        this.el = this.refs.container;

	        // Old versions of React doesn't return the raw DOM node
	        if (!(this.el instanceof window.Node)) {
	            this.el = this.el.getDOMNode();
	        }

	        if (this.props.startX) {
	            this.el.scrollLeft = this.props.startX;
	        }

	        if (this.props.startY) {
	            this.el.scrollTop = this.props.startY;
	        }
	    },

	    getContainerStyles: function() {
	        var style = {
	            overflow: 'hidden',
	            cursor: 'move'
	        };

	        if (this.props.width) {
	            style.width = this.props.width;
	        }

	        if (this.props.height) {
	            style.height = this.props.height;
	        }

	        if (this.props.style) {
	            style = Object.assign({}, style, this.props.style);
	        }

	        return style;
	    },

	    render: function() {
	        return (
	            React.DOM.div({
	                ref: 'container',
	                className: this.props.className,
	                style: this.getContainerStyles(),
	                onMouseDown: this.onDragStart,
	                onTouchStart: this.onDragStart
	            }, this.props.children)
	        );
	    }
	});

	module.exports = ElementPan;


/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root,factory){
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        module.exports = factory();
	    } else {
	        root.eventListener = factory();
	  }
	}(this, function () {
		function wrap(standard, fallback) {
			return function (el, evtName, listener, useCapture) {
				if (el[standard]) {
					el[standard](evtName, listener, useCapture);
				} else if (el[fallback]) {
					el[fallback]('on' + evtName, listener);
				}
			}
		}

	    return {
			add: wrap('addEventListener', 'attachEvent'),
			remove: wrap('removeEventListener', 'detachEvent')
		};
	}));

/***/ }
/******/ ])
});
;
